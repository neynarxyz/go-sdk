/*
Farcaster API V2

The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.

API version: 2.42.3
Contact: team@neynar.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package neynar_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

type CastAPI interface {

	/*
			DeleteCast Delete a cast

			Delete an existing cast. \
		(In order to delete a cast `signer_uuid` must be approved)


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiDeleteCastRequest
	*/
	DeleteCast(ctx context.Context) ApiDeleteCastRequest

	// DeleteCastExecute executes the request
	//  @return OperationResponse
	DeleteCastExecute(r ApiDeleteCastRequest) (*OperationResponse, *http.Response, error)

	/*
		FetchBulkCasts Bulk fetch casts

		Fetch multiple casts using their respective hashes.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchBulkCastsRequest
	*/
	FetchBulkCasts(ctx context.Context) ApiFetchBulkCastsRequest

	// FetchBulkCastsExecute executes the request
	//  @return CastsResponse
	FetchBulkCastsExecute(r ApiFetchBulkCastsRequest) (*CastsResponse, *http.Response, error)

	/*
		FetchComposerActions Fetch composer actions

		Fetches all composer actions on Warpcast. You can filter by top or featured.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchComposerActionsRequest
	*/
	FetchComposerActions(ctx context.Context) ApiFetchComposerActionsRequest

	// FetchComposerActionsExecute executes the request
	//  @return CastComposerActionsListResponse
	FetchComposerActionsExecute(r ApiFetchComposerActionsRequest) (*CastComposerActionsListResponse, *http.Response, error)

	/*
		FetchEmbeddedUrlMetadata Embedded URL metadata

		Crawls the given URL and returns metadata useful when embedding the URL in a cast.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchEmbeddedUrlMetadataRequest
	*/
	FetchEmbeddedUrlMetadata(ctx context.Context) ApiFetchEmbeddedUrlMetadataRequest

	// FetchEmbeddedUrlMetadataExecute executes the request
	//  @return CastEmbedCrawlResponse
	FetchEmbeddedUrlMetadataExecute(r ApiFetchEmbeddedUrlMetadataRequest) (*CastEmbedCrawlResponse, *http.Response, error)

	/*
		LookupCastByHashOrWarpcastUrl By hash or URL

		Gets information about an individual cast by passing in a Warpcast web URL or cast hash

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiLookupCastByHashOrWarpcastUrlRequest
	*/
	LookupCastByHashOrWarpcastUrl(ctx context.Context) ApiLookupCastByHashOrWarpcastUrlRequest

	// LookupCastByHashOrWarpcastUrlExecute executes the request
	//  @return CastResponse
	LookupCastByHashOrWarpcastUrlExecute(r ApiLookupCastByHashOrWarpcastUrlRequest) (*CastResponse, *http.Response, error)

	/*
		LookupCastConversation Conversation for a cast

		Gets all casts related to a conversation surrounding a cast by passing in a cast hash or Warpcast URL. Includes all the ancestors of a cast up to the root parent in a chronological order. Includes all direct_replies to the cast up to the reply_depth specified in the query parameter.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiLookupCastConversationRequest
	*/
	LookupCastConversation(ctx context.Context) ApiLookupCastConversationRequest

	// LookupCastConversationExecute executes the request
	//  @return Conversation
	LookupCastConversationExecute(r ApiLookupCastConversationRequest) (*Conversation, *http.Response, error)

	/*
			PublishCast Post a cast

			Posts a cast or cast reply. Works with mentions and embeds.
		(In order to post a cast `signer_uuid` must be approved)


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiPublishCastRequest
	*/
	PublishCast(ctx context.Context) ApiPublishCastRequest

	// PublishCastExecute executes the request
	//  @return PostCastResponse
	PublishCastExecute(r ApiPublishCastRequest) (*PostCastResponse, *http.Response, error)

	/*
		SearchCasts Search for casts

		Search for casts based on a query string, with optional AND filters

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSearchCastsRequest
	*/
	SearchCasts(ctx context.Context) ApiSearchCastsRequest

	// SearchCastsExecute executes the request
	//  @return CastsSearchResponse
	SearchCastsExecute(r ApiSearchCastsRequest) (*CastsSearchResponse, *http.Response, error)
}

// CastAPIService CastAPI service
type CastAPIService service

type ApiDeleteCastRequest struct {
	ctx               context.Context
	ApiService        CastAPI
	deleteCastReqBody *DeleteCastReqBody
}

func (r ApiDeleteCastRequest) DeleteCastReqBody(deleteCastReqBody DeleteCastReqBody) ApiDeleteCastRequest {
	r.deleteCastReqBody = &deleteCastReqBody
	return r
}

func (r ApiDeleteCastRequest) Execute() (*OperationResponse, *http.Response, error) {
	return r.ApiService.DeleteCastExecute(r)
}

/*
DeleteCast Delete a cast

Delete an existing cast. \
(In order to delete a cast `signer_uuid` must be approved)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteCastRequest
*/
func (a *CastAPIService) DeleteCast(ctx context.Context) ApiDeleteCastRequest {
	return ApiDeleteCastRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OperationResponse
func (a *CastAPIService) DeleteCastExecute(r ApiDeleteCastRequest) (*OperationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OperationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CastAPIService.DeleteCast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/cast"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteCastReqBody == nil {
		return localVarReturnValue, nil, reportError("deleteCastReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteCastReqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchBulkCastsRequest struct {
	ctx                 context.Context
	ApiService          CastAPI
	casts               *string
	viewerFid           *int32
	sortType            *string
	xNeynarExperimental *bool
}

// Hashes of the cast to be retrived (Comma separated, no spaces)
func (r ApiFetchBulkCastsRequest) Casts(casts string) ApiFetchBulkCastsRequest {
	r.casts = &casts
	return r
}

// adds viewer_context to cast object to show whether viewer has liked or recasted the cast.
func (r ApiFetchBulkCastsRequest) ViewerFid(viewerFid int32) ApiFetchBulkCastsRequest {
	r.viewerFid = &viewerFid
	return r
}

// Optional parameter to sort the casts based on different criteria
func (r ApiFetchBulkCastsRequest) SortType(sortType string) ApiFetchBulkCastsRequest {
	r.sortType = &sortType
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiFetchBulkCastsRequest) XNeynarExperimental(xNeynarExperimental bool) ApiFetchBulkCastsRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiFetchBulkCastsRequest) Execute() (*CastsResponse, *http.Response, error) {
	return r.ApiService.FetchBulkCastsExecute(r)
}

/*
FetchBulkCasts Bulk fetch casts

Fetch multiple casts using their respective hashes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchBulkCastsRequest
*/
func (a *CastAPIService) FetchBulkCasts(ctx context.Context) ApiFetchBulkCastsRequest {
	return ApiFetchBulkCastsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CastsResponse
func (a *CastAPIService) FetchBulkCastsExecute(r ApiFetchBulkCastsRequest) (*CastsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CastsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CastAPIService.FetchBulkCasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/casts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.casts == nil {
		return localVarReturnValue, nil, reportError("casts is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "casts", r.casts, "form", "")
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_type", r.sortType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchComposerActionsRequest struct {
	ctx        context.Context
	ApiService CastAPI
	list       *CastComposerType
	limit      *int32
	cursor     *string
}

// Type of list to fetch.
func (r ApiFetchComposerActionsRequest) List(list CastComposerType) ApiFetchComposerActionsRequest {
	r.list = &list
	return r
}

// Number of results to fetch
func (r ApiFetchComposerActionsRequest) Limit(limit int32) ApiFetchComposerActionsRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFetchComposerActionsRequest) Cursor(cursor string) ApiFetchComposerActionsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFetchComposerActionsRequest) Execute() (*CastComposerActionsListResponse, *http.Response, error) {
	return r.ApiService.FetchComposerActionsExecute(r)
}

/*
FetchComposerActions Fetch composer actions

Fetches all composer actions on Warpcast. You can filter by top or featured.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchComposerActionsRequest
*/
func (a *CastAPIService) FetchComposerActions(ctx context.Context) ApiFetchComposerActionsRequest {
	return ApiFetchComposerActionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CastComposerActionsListResponse
func (a *CastAPIService) FetchComposerActionsExecute(r ApiFetchComposerActionsRequest) (*CastComposerActionsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CastComposerActionsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CastAPIService.FetchComposerActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/cast/composer_actions/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.list == nil {
		return localVarReturnValue, nil, reportError("list is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "list", r.list, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchEmbeddedUrlMetadataRequest struct {
	ctx        context.Context
	ApiService CastAPI
	url        *string
}

// URL to crawl metadata of
func (r ApiFetchEmbeddedUrlMetadataRequest) Url(url string) ApiFetchEmbeddedUrlMetadataRequest {
	r.url = &url
	return r
}

func (r ApiFetchEmbeddedUrlMetadataRequest) Execute() (*CastEmbedCrawlResponse, *http.Response, error) {
	return r.ApiService.FetchEmbeddedUrlMetadataExecute(r)
}

/*
FetchEmbeddedUrlMetadata Embedded URL metadata

Crawls the given URL and returns metadata useful when embedding the URL in a cast.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchEmbeddedUrlMetadataRequest
*/
func (a *CastAPIService) FetchEmbeddedUrlMetadata(ctx context.Context) ApiFetchEmbeddedUrlMetadataRequest {
	return ApiFetchEmbeddedUrlMetadataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CastEmbedCrawlResponse
func (a *CastAPIService) FetchEmbeddedUrlMetadataExecute(r ApiFetchEmbeddedUrlMetadataRequest) (*CastEmbedCrawlResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CastEmbedCrawlResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CastAPIService.FetchEmbeddedUrlMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/cast/embed/crawl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookupCastByHashOrWarpcastUrlRequest struct {
	ctx                 context.Context
	ApiService          CastAPI
	identifier          *string
	type_               *CastParamType
	viewerFid           *int32
	xNeynarExperimental *bool
}

// Cast identifier (Its either a url or a hash)
func (r ApiLookupCastByHashOrWarpcastUrlRequest) Identifier(identifier string) ApiLookupCastByHashOrWarpcastUrlRequest {
	r.identifier = &identifier
	return r
}

func (r ApiLookupCastByHashOrWarpcastUrlRequest) Type_(type_ CastParamType) ApiLookupCastByHashOrWarpcastUrlRequest {
	r.type_ = &type_
	return r
}

// adds viewer_context to cast object to show whether viewer has liked or recasted the cast.
func (r ApiLookupCastByHashOrWarpcastUrlRequest) ViewerFid(viewerFid int32) ApiLookupCastByHashOrWarpcastUrlRequest {
	r.viewerFid = &viewerFid
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiLookupCastByHashOrWarpcastUrlRequest) XNeynarExperimental(xNeynarExperimental bool) ApiLookupCastByHashOrWarpcastUrlRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiLookupCastByHashOrWarpcastUrlRequest) Execute() (*CastResponse, *http.Response, error) {
	return r.ApiService.LookupCastByHashOrWarpcastUrlExecute(r)
}

/*
LookupCastByHashOrWarpcastUrl By hash or URL

Gets information about an individual cast by passing in a Warpcast web URL or cast hash

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLookupCastByHashOrWarpcastUrlRequest
*/
func (a *CastAPIService) LookupCastByHashOrWarpcastUrl(ctx context.Context) ApiLookupCastByHashOrWarpcastUrlRequest {
	return ApiLookupCastByHashOrWarpcastUrlRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CastResponse
func (a *CastAPIService) LookupCastByHashOrWarpcastUrlExecute(r ApiLookupCastByHashOrWarpcastUrlRequest) (*CastResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CastResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CastAPIService.LookupCastByHashOrWarpcastUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/cast"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.identifier == nil {
		return localVarReturnValue, nil, reportError("identifier is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookupCastConversationRequest struct {
	ctx                             context.Context
	ApiService                      CastAPI
	identifier                      *string
	type_                           *CastParamType
	replyDepth                      *int32
	includeChronologicalParentCasts *bool
	viewerFid                       *int32
	sortType                        *CastConversationSortType
	fold                            *string
	limit                           *int32
	cursor                          *string
	xNeynarExperimental             *bool
}

// Cast identifier (Its either a url or a hash)
func (r ApiLookupCastConversationRequest) Identifier(identifier string) ApiLookupCastConversationRequest {
	r.identifier = &identifier
	return r
}

func (r ApiLookupCastConversationRequest) Type_(type_ CastParamType) ApiLookupCastConversationRequest {
	r.type_ = &type_
	return r
}

// The depth of replies in the conversation that will be returned (default 2)
func (r ApiLookupCastConversationRequest) ReplyDepth(replyDepth int32) ApiLookupCastConversationRequest {
	r.replyDepth = &replyDepth
	return r
}

// Include all parent casts in chronological order
func (r ApiLookupCastConversationRequest) IncludeChronologicalParentCasts(includeChronologicalParentCasts bool) ApiLookupCastConversationRequest {
	r.includeChronologicalParentCasts = &includeChronologicalParentCasts
	return r
}

// Providing this will return a conversation that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiLookupCastConversationRequest) ViewerFid(viewerFid int32) ApiLookupCastConversationRequest {
	r.viewerFid = &viewerFid
	return r
}

// Sort type for the ordering of descendants. Default is &#x60;chron&#x60;
func (r ApiLookupCastConversationRequest) SortType(sortType CastConversationSortType) ApiLookupCastConversationRequest {
	r.sortType = &sortType
	return r
}

// Show conversation above or below the fold. Lower quality responses are hidden below the fold. Not passing in a value shows the full conversation without any folding.
func (r ApiLookupCastConversationRequest) Fold(fold string) ApiLookupCastConversationRequest {
	r.fold = &fold
	return r
}

// Number of results to fetch
func (r ApiLookupCastConversationRequest) Limit(limit int32) ApiLookupCastConversationRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiLookupCastConversationRequest) Cursor(cursor string) ApiLookupCastConversationRequest {
	r.cursor = &cursor
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiLookupCastConversationRequest) XNeynarExperimental(xNeynarExperimental bool) ApiLookupCastConversationRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiLookupCastConversationRequest) Execute() (*Conversation, *http.Response, error) {
	return r.ApiService.LookupCastConversationExecute(r)
}

/*
LookupCastConversation Conversation for a cast

Gets all casts related to a conversation surrounding a cast by passing in a cast hash or Warpcast URL. Includes all the ancestors of a cast up to the root parent in a chronological order. Includes all direct_replies to the cast up to the reply_depth specified in the query parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLookupCastConversationRequest
*/
func (a *CastAPIService) LookupCastConversation(ctx context.Context) ApiLookupCastConversationRequest {
	return ApiLookupCastConversationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Conversation
func (a *CastAPIService) LookupCastConversationExecute(r ApiLookupCastConversationRequest) (*Conversation, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Conversation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CastAPIService.LookupCastConversation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/cast/conversation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.identifier == nil {
		return localVarReturnValue, nil, reportError("identifier is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "identifier", r.identifier, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.replyDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reply_depth", r.replyDepth, "form", "")
	} else {
		var defaultValue int32 = 2
		r.replyDepth = &defaultValue
	}
	if r.includeChronologicalParentCasts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_chronological_parent_casts", r.includeChronologicalParentCasts, "form", "")
	} else {
		var defaultValue bool = false
		r.includeChronologicalParentCasts = &defaultValue
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_type", r.sortType, "form", "")
	}
	if r.fold != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fold", r.fold, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishCastRequest struct {
	ctx             context.Context
	ApiService      CastAPI
	postCastReqBody *PostCastReqBody
}

func (r ApiPublishCastRequest) PostCastReqBody(postCastReqBody PostCastReqBody) ApiPublishCastRequest {
	r.postCastReqBody = &postCastReqBody
	return r
}

func (r ApiPublishCastRequest) Execute() (*PostCastResponse, *http.Response, error) {
	return r.ApiService.PublishCastExecute(r)
}

/*
PublishCast Post a cast

Posts a cast or cast reply. Works with mentions and embeds.
(In order to post a cast `signer_uuid` must be approved)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPublishCastRequest
*/
func (a *CastAPIService) PublishCast(ctx context.Context) ApiPublishCastRequest {
	return ApiPublishCastRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostCastResponse
func (a *CastAPIService) PublishCastExecute(r ApiPublishCastRequest) (*PostCastResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostCastResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CastAPIService.PublishCast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/cast"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postCastReqBody == nil {
		return localVarReturnValue, nil, reportError("postCastReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postCastReqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchCastsRequest struct {
	ctx                 context.Context
	ApiService          CastAPI
	q                   *string
	mode                *string
	sortType            *SearchSortType
	authorFid           *int32
	viewerFid           *int32
	parentUrl           *string
	channelId           *string
	priorityMode        *bool
	limit               *int32
	cursor              *string
	xNeynarExperimental *bool
}

// Query string to search for casts. Supported operators:  | Operator  | Description                                                                                              | | --------- | -------------------------------------------------------------------------------------------------------- | | &#x60;+&#x60;       | Acts as the AND operator. This is the default operator between terms and can usually be omitted.         | | &#x60;\\|&#x60;      | Acts as the OR operator.                                                                                 | | &#x60;*&#x60;       | When used at the end of a term, signifies a prefix query.                                                  | | &#x60;\&quot;&#x60;       | Wraps several terms into a phrase (for example, &#x60;\&quot;star wars\&quot;&#x60;).                                          | | &#x60;(&#x60;, &#x60;)&#x60;  | Wrap a clause for precedence (for example, &#x60;star + (wars \\| trek)&#x60;).                                     | | &#x60;~n&#x60;      | When used after a term (for example, &#x60;satr~3&#x60;), sets &#x60;fuzziness&#x60;. When used after a phrase, sets &#x60;slop&#x60;. | | &#x60;-&#x60;       | Negates the term.                                                                                        | | &#x60;before:&#x60; | Search for casts before a specific date. (e.g. &#x60;before:2025-04-20&#x60;)                                       | | &#x60;after:&#x60;  | Search for casts after a specific date. (e.g. &#x60;after:2025-04-20&#x60;)                                         |
func (r ApiSearchCastsRequest) Q(q string) ApiSearchCastsRequest {
	r.q = &q
	return r
}

// Choices are: - &#x60;literal&#x60; - Searches for the words in the query string (default) - &#x60;semantic&#x60; - Searches for the meaning of the query string - &#x60;hybrid&#x60; - Combines both literal and semantic results
func (r ApiSearchCastsRequest) Mode(mode string) ApiSearchCastsRequest {
	r.mode = &mode
	return r
}

// Choices are: - &#x60;desc_chron&#x60; - All casts sorted by time (default) - &#x60;algorithmic&#x60; - Casts sorted by engagement and time
func (r ApiSearchCastsRequest) SortType(sortType SearchSortType) ApiSearchCastsRequest {
	r.sortType = &sortType
	return r
}

// Fid of the user whose casts you want to search
func (r ApiSearchCastsRequest) AuthorFid(authorFid int32) ApiSearchCastsRequest {
	r.authorFid = &authorFid
	return r
}

// Providing this will return search results that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiSearchCastsRequest) ViewerFid(viewerFid int32) ApiSearchCastsRequest {
	r.viewerFid = &viewerFid
	return r
}

// Parent URL of the casts you want to search
func (r ApiSearchCastsRequest) ParentUrl(parentUrl string) ApiSearchCastsRequest {
	r.parentUrl = &parentUrl
	return r
}

// Channel ID of the casts you want to search
func (r ApiSearchCastsRequest) ChannelId(channelId string) ApiSearchCastsRequest {
	r.channelId = &channelId
	return r
}

// When true, only returns search results from power badge users and users that the viewer follows (if viewer_fid is provided).
func (r ApiSearchCastsRequest) PriorityMode(priorityMode bool) ApiSearchCastsRequest {
	r.priorityMode = &priorityMode
	return r
}

// Number of results to fetch
func (r ApiSearchCastsRequest) Limit(limit int32) ApiSearchCastsRequest {
	r.limit = &limit
	return r
}

// Pagination cursor
func (r ApiSearchCastsRequest) Cursor(cursor string) ApiSearchCastsRequest {
	r.cursor = &cursor
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiSearchCastsRequest) XNeynarExperimental(xNeynarExperimental bool) ApiSearchCastsRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiSearchCastsRequest) Execute() (*CastsSearchResponse, *http.Response, error) {
	return r.ApiService.SearchCastsExecute(r)
}

/*
SearchCasts Search for casts

Search for casts based on a query string, with optional AND filters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchCastsRequest
*/
func (a *CastAPIService) SearchCasts(ctx context.Context) ApiSearchCastsRequest {
	return ApiSearchCastsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CastsSearchResponse
func (a *CastAPIService) SearchCastsExecute(r ApiSearchCastsRequest) (*CastsSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CastsSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CastAPIService.SearchCasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/cast/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_type", r.sortType, "form", "")
	}
	if r.authorFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "author_fid", r.authorFid, "form", "")
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.parentUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_url", r.parentUrl, "form", "")
	}
	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channel_id", r.channelId, "form", "")
	}
	if r.priorityMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority_mode", r.priorityMode, "form", "")
	} else {
		var defaultValue bool = false
		r.priorityMode = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
