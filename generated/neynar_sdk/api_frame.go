/*
Farcaster API V2

The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.

API version: 2.43.0
Contact: team@neynar.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package neynar_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)

type FrameAPI interface {

	/*
		DeleteNeynarFrame Delete mini app

		Delete an existing mini app, if it was made by the developer (identified by API key)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiDeleteNeynarFrameRequest
	*/
	DeleteNeynarFrame(ctx context.Context) ApiDeleteNeynarFrameRequest

	// DeleteNeynarFrameExecute executes the request
	//  @return DeleteFrameResponse
	DeleteNeynarFrameExecute(r ApiDeleteNeynarFrameRequest) (*DeleteFrameResponse, *http.Response, error)

	/*
		FetchFrameCatalog Mini apps catalog

		A curated list of featured mini apps

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchFrameCatalogRequest
	*/
	FetchFrameCatalog(ctx context.Context) ApiFetchFrameCatalogRequest

	// FetchFrameCatalogExecute executes the request
	//  @return FrameCatalogResponse
	FetchFrameCatalogExecute(r ApiFetchFrameCatalogRequest) (*FrameCatalogResponse, *http.Response, error)

	/*
		FetchFrameMetaTagsFromUrl Meta tags from URL

		Fetches the mini app meta tags from the URL

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchFrameMetaTagsFromUrlRequest
	*/
	FetchFrameMetaTagsFromUrl(ctx context.Context) ApiFetchFrameMetaTagsFromUrlRequest

	// FetchFrameMetaTagsFromUrlExecute executes the request
	//  @return FetchFrameMetaTagsFromUrl200Response
	FetchFrameMetaTagsFromUrlExecute(r ApiFetchFrameMetaTagsFromUrlRequest) (*FetchFrameMetaTagsFromUrl200Response, *http.Response, error)

	/*
		FetchNeynarFrames List of mini apps

		Fetch a list of mini apps made by the developer (identified by API key)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchNeynarFramesRequest
	*/
	FetchNeynarFrames(ctx context.Context) ApiFetchNeynarFramesRequest

	// FetchNeynarFramesExecute executes the request
	//  @return []NeynarFrame
	FetchNeynarFramesExecute(r ApiFetchNeynarFramesRequest) ([]NeynarFrame, *http.Response, error)

	/*
		FetchNotificationTokens List of mini app notification tokens

		Returns a list of notifications tokens related to a mini app


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchNotificationTokensRequest
	*/
	FetchNotificationTokens(ctx context.Context) ApiFetchNotificationTokensRequest

	// FetchNotificationTokensExecute executes the request
	//  @return FrameNotificationTokens
	FetchNotificationTokensExecute(r ApiFetchNotificationTokensRequest) (*FrameNotificationTokens, *http.Response, error)

	/*
		FetchRelevantFrames Relevant mini apps

		Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchRelevantFramesRequest
	*/
	FetchRelevantFrames(ctx context.Context) ApiFetchRelevantFramesRequest

	// FetchRelevantFramesExecute executes the request
	//  @return FetchRelevantFrames200Response
	FetchRelevantFramesExecute(r ApiFetchRelevantFramesRequest) (*FetchRelevantFrames200Response, *http.Response, error)

	/*
		FetchValidateFrameAnalytics Analytics for the mini app

		Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchValidateFrameAnalyticsRequest
	*/
	FetchValidateFrameAnalytics(ctx context.Context) ApiFetchValidateFrameAnalyticsRequest

	// FetchValidateFrameAnalyticsExecute executes the request
	//  @return FrameValidateAnalyticsResponse
	FetchValidateFrameAnalyticsExecute(r ApiFetchValidateFrameAnalyticsRequest) (*FrameValidateAnalyticsResponse, *http.Response, error)

	/*
		FetchValidateFrameList All mini apps validated by user

		Fetch a list of all the mini apps validated by a user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchValidateFrameListRequest
	*/
	FetchValidateFrameList(ctx context.Context) ApiFetchValidateFrameListRequest

	// FetchValidateFrameListExecute executes the request
	//  @return FrameValidateListResponse
	FetchValidateFrameListExecute(r ApiFetchValidateFrameListRequest) (*FrameValidateListResponse, *http.Response, error)

	/*
		GetTransactionPayFrame Get transaction pay mini app

		Retrieves details about a transaction pay mini app by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetTransactionPayFrameRequest
	*/
	GetTransactionPayFrame(ctx context.Context) ApiGetTransactionPayFrameRequest

	// GetTransactionPayFrameExecute executes the request
	//  @return TransactionFrameResponse
	GetTransactionPayFrameExecute(r ApiGetTransactionPayFrameRequest) (*TransactionFrameResponse, *http.Response, error)

	/*
		LookupNeynarFrame Mini app by UUID or URL

		Fetch a mini app either by UUID or Neynar URL

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiLookupNeynarFrameRequest
	*/
	LookupNeynarFrame(ctx context.Context) ApiLookupNeynarFrameRequest

	// LookupNeynarFrameExecute executes the request
	//  @return NeynarFrame
	LookupNeynarFrameExecute(r ApiLookupNeynarFrameRequest) (*NeynarFrame, *http.Response, error)

	/*
			PostFrameAction Post a mini app action, cast action or a cast composer action

			Post mini app actions, cast actions or cast composer actions to the server  \
		(In order to post any of these actions, you need to have an approved `signer_uuid`)

		The POST request to the post_url has a timeout of 5 seconds for mini apps.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiPostFrameActionRequest
	*/
	PostFrameAction(ctx context.Context) ApiPostFrameActionRequest

	// PostFrameActionExecute executes the request
	//  @return Frame
	PostFrameActionExecute(r ApiPostFrameActionRequest) (*Frame, *http.Response, error)

	/*
			PostFrameActionDeveloperManaged Signature packet

			Post a mini app action that has been signed with a developer managed signer

		The POST request to the post_url has a timeout of 5 seconds.


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiPostFrameActionDeveloperManagedRequest
	*/
	PostFrameActionDeveloperManaged(ctx context.Context) ApiPostFrameActionDeveloperManagedRequest

	// PostFrameActionDeveloperManagedExecute executes the request
	//  @return Frame
	PostFrameActionDeveloperManagedExecute(r ApiPostFrameActionDeveloperManagedRequest) (*Frame, *http.Response, error)

	/*
		PublishFrameNotifications Send notifications

		Send notifications to interactors of a mini app


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiPublishFrameNotificationsRequest
	*/
	PublishFrameNotifications(ctx context.Context) ApiPublishFrameNotificationsRequest

	// PublishFrameNotificationsExecute executes the request
	//  @return SendFrameNotificationsResponse
	PublishFrameNotificationsExecute(r ApiPublishFrameNotificationsRequest) (*SendFrameNotificationsResponse, *http.Response, error)

	/*
		PublishNeynarFrame Create mini app

		Create a new mini app with a list of pages.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiPublishNeynarFrameRequest
	*/
	PublishNeynarFrame(ctx context.Context) ApiPublishNeynarFrameRequest

	// PublishNeynarFrameExecute executes the request
	//  @return NeynarFrame
	PublishNeynarFrameExecute(r ApiPublishNeynarFrameRequest) (*NeynarFrame, *http.Response, error)

	/*
		SearchFrames Search mini apps

		Search for mini apps based on a query string

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSearchFramesRequest
	*/
	SearchFrames(ctx context.Context) ApiSearchFramesRequest

	// SearchFramesExecute executes the request
	//  @return FrameCatalogResponse
	SearchFramesExecute(r ApiSearchFramesRequest) (*FrameCatalogResponse, *http.Response, error)

	/*
		UpdateNeynarFrame Update mini app

		Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiUpdateNeynarFrameRequest
	*/
	UpdateNeynarFrame(ctx context.Context) ApiUpdateNeynarFrameRequest

	// UpdateNeynarFrameExecute executes the request
	//  @return NeynarFrame
	UpdateNeynarFrameExecute(r ApiUpdateNeynarFrameRequest) (*NeynarFrame, *http.Response, error)

	/*
			ValidateFrameAction Validate mini app action

			Validates a mini app against by an interacting user against a Farcaster Hub \
		(In order to validate a mini app, message bytes from Frame Action must be provided in hex)


			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ApiValidateFrameActionRequest
	*/
	ValidateFrameAction(ctx context.Context) ApiValidateFrameActionRequest

	// ValidateFrameActionExecute executes the request
	//  @return ValidateFrameActionResponse
	ValidateFrameActionExecute(r ApiValidateFrameActionRequest) (*ValidateFrameActionResponse, *http.Response, error)
}

// FrameAPIService FrameAPI service
type FrameAPIService service

type ApiDeleteNeynarFrameRequest struct {
	ctx                context.Context
	ApiService         FrameAPI
	deleteFrameReqBody *DeleteFrameReqBody
}

func (r ApiDeleteNeynarFrameRequest) DeleteFrameReqBody(deleteFrameReqBody DeleteFrameReqBody) ApiDeleteNeynarFrameRequest {
	r.deleteFrameReqBody = &deleteFrameReqBody
	return r
}

func (r ApiDeleteNeynarFrameRequest) Execute() (*DeleteFrameResponse, *http.Response, error) {
	return r.ApiService.DeleteNeynarFrameExecute(r)
}

/*
DeleteNeynarFrame Delete mini app

Delete an existing mini app, if it was made by the developer (identified by API key)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteNeynarFrameRequest
*/
func (a *FrameAPIService) DeleteNeynarFrame(ctx context.Context) ApiDeleteNeynarFrameRequest {
	return ApiDeleteNeynarFrameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DeleteFrameResponse
func (a *FrameAPIService) DeleteNeynarFrameExecute(r ApiDeleteNeynarFrameRequest) (*DeleteFrameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeleteFrameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.DeleteNeynarFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteFrameReqBody == nil {
		return localVarReturnValue, nil, reportError("deleteFrameReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteFrameReqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchFrameCatalogRequest struct {
	ctx        context.Context
	ApiService FrameAPI
	limit      *int32
	cursor     *string
	timeWindow *MiniAppTimeWindow
	categories *[]string
}

// Number of results to fetch
func (r ApiFetchFrameCatalogRequest) Limit(limit int32) ApiFetchFrameCatalogRequest {
	r.limit = &limit
	return r
}

// Pagination cursor
func (r ApiFetchFrameCatalogRequest) Cursor(cursor string) ApiFetchFrameCatalogRequest {
	r.cursor = &cursor
	return r
}

// Time window used to calculate the change in trending score for each mini app, used to sort mini app results
func (r ApiFetchFrameCatalogRequest) TimeWindow(timeWindow MiniAppTimeWindow) ApiFetchFrameCatalogRequest {
	r.timeWindow = &timeWindow
	return r
}

// Comma separated list of categories to include in the results.  Includes all if left blank.  Example: &#x60;categories&#x3D;games,social&#x60; OR: &#x60;categories&#x3D;games&amp;categories&#x3D;social&#x60;
func (r ApiFetchFrameCatalogRequest) Categories(categories []string) ApiFetchFrameCatalogRequest {
	r.categories = &categories
	return r
}

func (r ApiFetchFrameCatalogRequest) Execute() (*FrameCatalogResponse, *http.Response, error) {
	return r.ApiService.FetchFrameCatalogExecute(r)
}

/*
FetchFrameCatalog Mini apps catalog

A curated list of featured mini apps

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchFrameCatalogRequest
*/
func (a *FrameAPIService) FetchFrameCatalog(ctx context.Context) ApiFetchFrameCatalogRequest {
	return ApiFetchFrameCatalogRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FrameCatalogResponse
func (a *FrameAPIService) FetchFrameCatalogExecute(r ApiFetchFrameCatalogRequest) (*FrameCatalogResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FrameCatalogResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.FetchFrameCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/catalog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.timeWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_window", r.timeWindow, "form", "")
	} else {
		var defaultValue MiniAppTimeWindow = "7d"
		r.timeWindow = &defaultValue
	}
	if r.categories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categories", r.categories, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchFrameMetaTagsFromUrlRequest struct {
	ctx        context.Context
	ApiService FrameAPI
	url        *string
}

// The mini app URL to crawl
func (r ApiFetchFrameMetaTagsFromUrlRequest) Url(url string) ApiFetchFrameMetaTagsFromUrlRequest {
	r.url = &url
	return r
}

func (r ApiFetchFrameMetaTagsFromUrlRequest) Execute() (*FetchFrameMetaTagsFromUrl200Response, *http.Response, error) {
	return r.ApiService.FetchFrameMetaTagsFromUrlExecute(r)
}

/*
FetchFrameMetaTagsFromUrl Meta tags from URL

Fetches the mini app meta tags from the URL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchFrameMetaTagsFromUrlRequest
*/
func (a *FrameAPIService) FetchFrameMetaTagsFromUrl(ctx context.Context) ApiFetchFrameMetaTagsFromUrlRequest {
	return ApiFetchFrameMetaTagsFromUrlRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FetchFrameMetaTagsFromUrl200Response
func (a *FrameAPIService) FetchFrameMetaTagsFromUrlExecute(r ApiFetchFrameMetaTagsFromUrlRequest) (*FetchFrameMetaTagsFromUrl200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FetchFrameMetaTagsFromUrl200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.FetchFrameMetaTagsFromUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/crawl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchNeynarFramesRequest struct {
	ctx        context.Context
	ApiService FrameAPI
}

func (r ApiFetchNeynarFramesRequest) Execute() ([]NeynarFrame, *http.Response, error) {
	return r.ApiService.FetchNeynarFramesExecute(r)
}

/*
FetchNeynarFrames List of mini apps

Fetch a list of mini apps made by the developer (identified by API key)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchNeynarFramesRequest
*/
func (a *FrameAPIService) FetchNeynarFrames(ctx context.Context) ApiFetchNeynarFramesRequest {
	return ApiFetchNeynarFramesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []NeynarFrame
func (a *FrameAPIService) FetchNeynarFramesExecute(r ApiFetchNeynarFramesRequest) ([]NeynarFrame, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []NeynarFrame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.FetchNeynarFrames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchNotificationTokensRequest struct {
	ctx        context.Context
	ApiService FrameAPI
	limit      *int32
	fids       *string
	cursor     *string
}

// Number of results to fetch
func (r ApiFetchNotificationTokensRequest) Limit(limit int32) ApiFetchNotificationTokensRequest {
	r.limit = &limit
	return r
}

// Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don&#39;t pass in FIDs, you will get back all the notification tokens for the mini app.
func (r ApiFetchNotificationTokensRequest) Fids(fids string) ApiFetchNotificationTokensRequest {
	r.fids = &fids
	return r
}

// Pagination cursor
func (r ApiFetchNotificationTokensRequest) Cursor(cursor string) ApiFetchNotificationTokensRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFetchNotificationTokensRequest) Execute() (*FrameNotificationTokens, *http.Response, error) {
	return r.ApiService.FetchNotificationTokensExecute(r)
}

/*
FetchNotificationTokens List of mini app notification tokens

# Returns a list of notifications tokens related to a mini app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchNotificationTokensRequest
*/
func (a *FrameAPIService) FetchNotificationTokens(ctx context.Context) ApiFetchNotificationTokensRequest {
	return ApiFetchNotificationTokensRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FrameNotificationTokens
func (a *FrameAPIService) FetchNotificationTokensExecute(r ApiFetchNotificationTokensRequest) (*FrameNotificationTokens, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FrameNotificationTokens
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.FetchNotificationTokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/notification_tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.fids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fids", r.fids, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchRelevantFramesRequest struct {
	ctx        context.Context
	ApiService FrameAPI
	viewerFid  *int32
	timeWindow *MiniAppTimeWindow
}

// FID of the user to fetch relevant mini apps for
func (r ApiFetchRelevantFramesRequest) ViewerFid(viewerFid int32) ApiFetchRelevantFramesRequest {
	r.viewerFid = &viewerFid
	return r
}

// Time window used to limit statistics used to calculate mini app relevance
func (r ApiFetchRelevantFramesRequest) TimeWindow(timeWindow MiniAppTimeWindow) ApiFetchRelevantFramesRequest {
	r.timeWindow = &timeWindow
	return r
}

func (r ApiFetchRelevantFramesRequest) Execute() (*FetchRelevantFrames200Response, *http.Response, error) {
	return r.ApiService.FetchRelevantFramesExecute(r)
}

/*
FetchRelevantFrames Relevant mini apps

Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchRelevantFramesRequest
*/
func (a *FrameAPIService) FetchRelevantFrames(ctx context.Context) ApiFetchRelevantFramesRequest {
	return ApiFetchRelevantFramesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FetchRelevantFrames200Response
func (a *FrameAPIService) FetchRelevantFramesExecute(r ApiFetchRelevantFramesRequest) (*FetchRelevantFrames200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FetchRelevantFrames200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.FetchRelevantFrames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/relevant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.viewerFid == nil {
		return localVarReturnValue, nil, reportError("viewerFid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	if r.timeWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_window", r.timeWindow, "form", "")
	} else {
		var defaultValue MiniAppTimeWindow = "7d"
		r.timeWindow = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchValidateFrameAnalyticsRequest struct {
	ctx             context.Context
	ApiService      FrameAPI
	frameUrl        *string
	analyticsType   *ValidateFrameAnalyticsType
	start           *time.Time
	stop            *time.Time
	aggregateWindow *ValidateFrameAggregateWindow
}

func (r ApiFetchValidateFrameAnalyticsRequest) FrameUrl(frameUrl string) ApiFetchValidateFrameAnalyticsRequest {
	r.frameUrl = &frameUrl
	return r
}

func (r ApiFetchValidateFrameAnalyticsRequest) AnalyticsType(analyticsType ValidateFrameAnalyticsType) ApiFetchValidateFrameAnalyticsRequest {
	r.analyticsType = &analyticsType
	return r
}

func (r ApiFetchValidateFrameAnalyticsRequest) Start(start time.Time) ApiFetchValidateFrameAnalyticsRequest {
	r.start = &start
	return r
}

func (r ApiFetchValidateFrameAnalyticsRequest) Stop(stop time.Time) ApiFetchValidateFrameAnalyticsRequest {
	r.stop = &stop
	return r
}

// Required for &#x60;analytics_type&#x3D;interactions-per-cast&#x60;
func (r ApiFetchValidateFrameAnalyticsRequest) AggregateWindow(aggregateWindow ValidateFrameAggregateWindow) ApiFetchValidateFrameAnalyticsRequest {
	r.aggregateWindow = &aggregateWindow
	return r
}

func (r ApiFetchValidateFrameAnalyticsRequest) Execute() (*FrameValidateAnalyticsResponse, *http.Response, error) {
	return r.ApiService.FetchValidateFrameAnalyticsExecute(r)
}

/*
FetchValidateFrameAnalytics Analytics for the mini app

Fetch analytics for total-interactors, interactors, nteractions-per-cast and input-text.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchValidateFrameAnalyticsRequest
*/
func (a *FrameAPIService) FetchValidateFrameAnalytics(ctx context.Context) ApiFetchValidateFrameAnalyticsRequest {
	return ApiFetchValidateFrameAnalyticsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FrameValidateAnalyticsResponse
func (a *FrameAPIService) FetchValidateFrameAnalyticsExecute(r ApiFetchValidateFrameAnalyticsRequest) (*FrameValidateAnalyticsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FrameValidateAnalyticsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.FetchValidateFrameAnalytics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/validate/analytics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.frameUrl == nil {
		return localVarReturnValue, nil, reportError("frameUrl is required and must be specified")
	}
	if r.analyticsType == nil {
		return localVarReturnValue, nil, reportError("analyticsType is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.stop == nil {
		return localVarReturnValue, nil, reportError("stop is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "frame_url", r.frameUrl, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "analytics_type", r.analyticsType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "stop", r.stop, "form", "")
	if r.aggregateWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate_window", r.aggregateWindow, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchValidateFrameListRequest struct {
	ctx        context.Context
	ApiService FrameAPI
}

func (r ApiFetchValidateFrameListRequest) Execute() (*FrameValidateListResponse, *http.Response, error) {
	return r.ApiService.FetchValidateFrameListExecute(r)
}

/*
FetchValidateFrameList All mini apps validated by user

Fetch a list of all the mini apps validated by a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchValidateFrameListRequest
*/
func (a *FrameAPIService) FetchValidateFrameList(ctx context.Context) ApiFetchValidateFrameListRequest {
	return ApiFetchValidateFrameListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FrameValidateListResponse
func (a *FrameAPIService) FetchValidateFrameListExecute(r ApiFetchValidateFrameListRequest) (*FrameValidateListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FrameValidateListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.FetchValidateFrameList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/validate/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionPayFrameRequest struct {
	ctx        context.Context
	ApiService FrameAPI
	id         *string
}

// ID of the transaction mini app to retrieve
func (r ApiGetTransactionPayFrameRequest) Id(id string) ApiGetTransactionPayFrameRequest {
	r.id = &id
	return r
}

func (r ApiGetTransactionPayFrameRequest) Execute() (*TransactionFrameResponse, *http.Response, error) {
	return r.ApiService.GetTransactionPayFrameExecute(r)
}

/*
GetTransactionPayFrame Get transaction pay mini app

Retrieves details about a transaction pay mini app by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTransactionPayFrameRequest
*/
func (a *FrameAPIService) GetTransactionPayFrame(ctx context.Context) ApiGetTransactionPayFrameRequest {
	return ApiGetTransactionPayFrameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TransactionFrameResponse
func (a *FrameAPIService) GetTransactionPayFrameExecute(r ApiGetTransactionPayFrameRequest) (*TransactionFrameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TransactionFrameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.GetTransactionPayFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/transaction/pay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookupNeynarFrameRequest struct {
	ctx        context.Context
	ApiService FrameAPI
	type_      *FrameType
	uuid       *string
	url        *string
}

func (r ApiLookupNeynarFrameRequest) Type_(type_ FrameType) ApiLookupNeynarFrameRequest {
	r.type_ = &type_
	return r
}

// UUID of the mini app to fetch
func (r ApiLookupNeynarFrameRequest) Uuid(uuid string) ApiLookupNeynarFrameRequest {
	r.uuid = &uuid
	return r
}

// URL of the Neynar mini app to fetch
func (r ApiLookupNeynarFrameRequest) Url(url string) ApiLookupNeynarFrameRequest {
	r.url = &url
	return r
}

func (r ApiLookupNeynarFrameRequest) Execute() (*NeynarFrame, *http.Response, error) {
	return r.ApiService.LookupNeynarFrameExecute(r)
}

/*
LookupNeynarFrame Mini app by UUID or URL

Fetch a mini app either by UUID or Neynar URL

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLookupNeynarFrameRequest
*/
func (a *FrameAPIService) LookupNeynarFrame(ctx context.Context) ApiLookupNeynarFrameRequest {
	return ApiLookupNeynarFrameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return NeynarFrame
func (a *FrameAPIService) LookupNeynarFrameExecute(r ApiLookupNeynarFrameRequest) (*NeynarFrame, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NeynarFrame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.LookupNeynarFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.uuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uuid", r.uuid, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFrameActionRequest struct {
	ctx                context.Context
	ApiService         FrameAPI
	frameActionReqBody *FrameActionReqBody
}

func (r ApiPostFrameActionRequest) FrameActionReqBody(frameActionReqBody FrameActionReqBody) ApiPostFrameActionRequest {
	r.frameActionReqBody = &frameActionReqBody
	return r
}

func (r ApiPostFrameActionRequest) Execute() (*Frame, *http.Response, error) {
	return r.ApiService.PostFrameActionExecute(r)
}

/*
PostFrameAction Post a mini app action, cast action or a cast composer action

Post mini app actions, cast actions or cast composer actions to the server  \
(In order to post any of these actions, you need to have an approved `signer_uuid`)

The POST request to the post_url has a timeout of 5 seconds for mini apps.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostFrameActionRequest
*/
func (a *FrameAPIService) PostFrameAction(ctx context.Context) ApiPostFrameActionRequest {
	return ApiPostFrameActionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Frame
func (a *FrameAPIService) PostFrameActionExecute(r ApiPostFrameActionRequest) (*Frame, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Frame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.PostFrameAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.frameActionReqBody == nil {
		return localVarReturnValue, nil, reportError("frameActionReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.frameActionReqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFrameActionDeveloperManagedRequest struct {
	ctx                                context.Context
	ApiService                         FrameAPI
	frameDeveloperManagedActionReqBody *FrameDeveloperManagedActionReqBody
}

func (r ApiPostFrameActionDeveloperManagedRequest) FrameDeveloperManagedActionReqBody(frameDeveloperManagedActionReqBody FrameDeveloperManagedActionReqBody) ApiPostFrameActionDeveloperManagedRequest {
	r.frameDeveloperManagedActionReqBody = &frameDeveloperManagedActionReqBody
	return r
}

func (r ApiPostFrameActionDeveloperManagedRequest) Execute() (*Frame, *http.Response, error) {
	return r.ApiService.PostFrameActionDeveloperManagedExecute(r)
}

/*
PostFrameActionDeveloperManaged Signature packet

# Post a mini app action that has been signed with a developer managed signer

The POST request to the post_url has a timeout of 5 seconds.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostFrameActionDeveloperManagedRequest
*/
func (a *FrameAPIService) PostFrameActionDeveloperManaged(ctx context.Context) ApiPostFrameActionDeveloperManagedRequest {
	return ApiPostFrameActionDeveloperManagedRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Frame
func (a *FrameAPIService) PostFrameActionDeveloperManagedExecute(r ApiPostFrameActionDeveloperManagedRequest) (*Frame, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Frame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.PostFrameActionDeveloperManaged")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/developer_managed/action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.frameDeveloperManagedActionReqBody == nil {
		return localVarReturnValue, nil, reportError("frameDeveloperManagedActionReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.frameDeveloperManagedActionReqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishFrameNotificationsRequest struct {
	ctx                           context.Context
	ApiService                    FrameAPI
	sendFrameNotificationsReqBody *SendFrameNotificationsReqBody
}

func (r ApiPublishFrameNotificationsRequest) SendFrameNotificationsReqBody(sendFrameNotificationsReqBody SendFrameNotificationsReqBody) ApiPublishFrameNotificationsRequest {
	r.sendFrameNotificationsReqBody = &sendFrameNotificationsReqBody
	return r
}

func (r ApiPublishFrameNotificationsRequest) Execute() (*SendFrameNotificationsResponse, *http.Response, error) {
	return r.ApiService.PublishFrameNotificationsExecute(r)
}

/*
PublishFrameNotifications Send notifications

# Send notifications to interactors of a mini app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPublishFrameNotificationsRequest
*/
func (a *FrameAPIService) PublishFrameNotifications(ctx context.Context) ApiPublishFrameNotificationsRequest {
	return ApiPublishFrameNotificationsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SendFrameNotificationsResponse
func (a *FrameAPIService) PublishFrameNotificationsExecute(r ApiPublishFrameNotificationsRequest) (*SendFrameNotificationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SendFrameNotificationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.PublishFrameNotifications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/notifications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sendFrameNotificationsReqBody == nil {
		return localVarReturnValue, nil, reportError("sendFrameNotificationsReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendFrameNotificationsReqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PublishFrameNotifications400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishNeynarFrameRequest struct {
	ctx                        context.Context
	ApiService                 FrameAPI
	neynarFrameCreationReqBody *NeynarFrameCreationReqBody
}

func (r ApiPublishNeynarFrameRequest) NeynarFrameCreationReqBody(neynarFrameCreationReqBody NeynarFrameCreationReqBody) ApiPublishNeynarFrameRequest {
	r.neynarFrameCreationReqBody = &neynarFrameCreationReqBody
	return r
}

func (r ApiPublishNeynarFrameRequest) Execute() (*NeynarFrame, *http.Response, error) {
	return r.ApiService.PublishNeynarFrameExecute(r)
}

/*
PublishNeynarFrame Create mini app

Create a new mini app with a list of pages.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPublishNeynarFrameRequest
*/
func (a *FrameAPIService) PublishNeynarFrame(ctx context.Context) ApiPublishNeynarFrameRequest {
	return ApiPublishNeynarFrameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return NeynarFrame
func (a *FrameAPIService) PublishNeynarFrameExecute(r ApiPublishNeynarFrameRequest) (*NeynarFrame, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NeynarFrame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.PublishNeynarFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.neynarFrameCreationReqBody == nil {
		return localVarReturnValue, nil, reportError("neynarFrameCreationReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.neynarFrameCreationReqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchFramesRequest struct {
	ctx        context.Context
	ApiService FrameAPI
	q          *string
	limit      *int32
	cursor     *string
}

// Query string to search for mini apps
func (r ApiSearchFramesRequest) Q(q string) ApiSearchFramesRequest {
	r.q = &q
	return r
}

// Number of results to fetch
func (r ApiSearchFramesRequest) Limit(limit int32) ApiSearchFramesRequest {
	r.limit = &limit
	return r
}

// Pagination cursor
func (r ApiSearchFramesRequest) Cursor(cursor string) ApiSearchFramesRequest {
	r.cursor = &cursor
	return r
}

func (r ApiSearchFramesRequest) Execute() (*FrameCatalogResponse, *http.Response, error) {
	return r.ApiService.SearchFramesExecute(r)
}

/*
SearchFrames Search mini apps

Search for mini apps based on a query string

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchFramesRequest
*/
func (a *FrameAPIService) SearchFrames(ctx context.Context) ApiSearchFramesRequest {
	return ApiSearchFramesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FrameCatalogResponse
func (a *FrameAPIService) SearchFramesExecute(r ApiSearchFramesRequest) (*FrameCatalogResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FrameCatalogResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.SearchFrames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNeynarFrameRequest struct {
	ctx                      context.Context
	ApiService               FrameAPI
	neynarFrameUpdateReqBody *NeynarFrameUpdateReqBody
}

func (r ApiUpdateNeynarFrameRequest) NeynarFrameUpdateReqBody(neynarFrameUpdateReqBody NeynarFrameUpdateReqBody) ApiUpdateNeynarFrameRequest {
	r.neynarFrameUpdateReqBody = &neynarFrameUpdateReqBody
	return r
}

func (r ApiUpdateNeynarFrameRequest) Execute() (*NeynarFrame, *http.Response, error) {
	return r.ApiService.UpdateNeynarFrameExecute(r)
}

/*
UpdateNeynarFrame Update mini app

Update an existing mini app with a list of pages, if it was made by the developer (identified by API key)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateNeynarFrameRequest
*/
func (a *FrameAPIService) UpdateNeynarFrame(ctx context.Context) ApiUpdateNeynarFrameRequest {
	return ApiUpdateNeynarFrameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return NeynarFrame
func (a *FrameAPIService) UpdateNeynarFrameExecute(r ApiUpdateNeynarFrameRequest) (*NeynarFrame, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NeynarFrame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.UpdateNeynarFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.neynarFrameUpdateReqBody == nil {
		return localVarReturnValue, nil, reportError("neynarFrameUpdateReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.neynarFrameUpdateReqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateFrameActionRequest struct {
	ctx                        context.Context
	ApiService                 FrameAPI
	validateFrameActionReqBody *ValidateFrameActionReqBody
}

func (r ApiValidateFrameActionRequest) ValidateFrameActionReqBody(validateFrameActionReqBody ValidateFrameActionReqBody) ApiValidateFrameActionRequest {
	r.validateFrameActionReqBody = &validateFrameActionReqBody
	return r
}

func (r ApiValidateFrameActionRequest) Execute() (*ValidateFrameActionResponse, *http.Response, error) {
	return r.ApiService.ValidateFrameActionExecute(r)
}

/*
ValidateFrameAction Validate mini app action

Validates a mini app against by an interacting user against a Farcaster Hub \
(In order to validate a mini app, message bytes from Frame Action must be provided in hex)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiValidateFrameActionRequest
*/
func (a *FrameAPIService) ValidateFrameAction(ctx context.Context) ApiValidateFrameActionRequest {
	return ApiValidateFrameActionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ValidateFrameActionResponse
func (a *FrameAPIService) ValidateFrameActionExecute(r ApiValidateFrameActionRequest) (*ValidateFrameActionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ValidateFrameActionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.ValidateFrameAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validateFrameActionReqBody == nil {
		return localVarReturnValue, nil, reportError("validateFrameActionReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validateFrameActionReqBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
