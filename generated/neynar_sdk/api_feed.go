/*
Farcaster API V2

The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.

API version: 2.41.0
Contact: team@neynar.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package neynar_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

type FeedAPI interface {

	/*
		FetchCastsForUser Chronologically

		Fetch casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchCastsForUserRequest
	*/
	FetchCastsForUser(ctx context.Context) ApiFetchCastsForUserRequest

	// FetchCastsForUserExecute executes the request
	//  @return FeedResponse
	FetchCastsForUserExecute(r ApiFetchCastsForUserRequest) (*FeedResponse, *http.Response, error)

	/*
		FetchFeed By filters

		Fetch casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchFeedRequest
	*/
	FetchFeed(ctx context.Context) ApiFetchFeedRequest

	// FetchFeedExecute executes the request
	//  @return FeedResponse
	FetchFeedExecute(r ApiFetchFeedRequest) (*FeedResponse, *http.Response, error)

	/*
		FetchFeedByChannelIds By channel IDs

		Fetch feed based on channel IDs

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchFeedByChannelIdsRequest
	*/
	FetchFeedByChannelIds(ctx context.Context) ApiFetchFeedByChannelIdsRequest

	// FetchFeedByChannelIdsExecute executes the request
	//  @return FeedResponse
	FetchFeedByChannelIdsExecute(r ApiFetchFeedByChannelIdsRequest) (*FeedResponse, *http.Response, error)

	/*
		FetchFeedByParentUrls By parent URLs

		Fetch feed based on parent URLs

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchFeedByParentUrlsRequest
	*/
	FetchFeedByParentUrls(ctx context.Context) ApiFetchFeedByParentUrlsRequest

	// FetchFeedByParentUrlsExecute executes the request
	//  @return FeedResponse
	FetchFeedByParentUrlsExecute(r ApiFetchFeedByParentUrlsRequest) (*FeedResponse, *http.Response, error)

	/*
		FetchFeedForYou For you

		Fetch a personalized For You feed for a user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchFeedForYouRequest
	*/
	FetchFeedForYou(ctx context.Context) ApiFetchFeedForYouRequest

	// FetchFeedForYouExecute executes the request
	//  @return FeedResponse
	FetchFeedForYouExecute(r ApiFetchFeedForYouRequest) (*FeedResponse, *http.Response, error)

	/*
		FetchFramesOnlyFeed Casts with mini apps

		Fetch feed of casts with mini apps, reverse chronological order

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchFramesOnlyFeedRequest
	*/
	FetchFramesOnlyFeed(ctx context.Context) ApiFetchFramesOnlyFeedRequest

	// FetchFramesOnlyFeedExecute executes the request
	//  @return FeedResponse
	FetchFramesOnlyFeedExecute(r ApiFetchFramesOnlyFeedRequest) (*FeedResponse, *http.Response, error)

	/*
		FetchPopularCastsByUser 10 most popular casts

		Fetch 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchPopularCastsByUserRequest
	*/
	FetchPopularCastsByUser(ctx context.Context) ApiFetchPopularCastsByUserRequest

	// FetchPopularCastsByUserExecute executes the request
	//  @return BulkCastsResponse
	FetchPopularCastsByUserExecute(r ApiFetchPopularCastsByUserRequest) (*BulkCastsResponse, *http.Response, error)

	/*
		FetchRepliesAndRecastsForUser Replies and recasts

		Fetch recent replies and recasts for a given user FID; sorted by most recent first

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchRepliesAndRecastsForUserRequest
	*/
	FetchRepliesAndRecastsForUser(ctx context.Context) ApiFetchRepliesAndRecastsForUserRequest

	// FetchRepliesAndRecastsForUserExecute executes the request
	//  @return FeedResponse
	FetchRepliesAndRecastsForUserExecute(r ApiFetchRepliesAndRecastsForUserRequest) (*FeedResponse, *http.Response, error)

	/*
		FetchTrendingFeed Trending feeds

		Fetch trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchTrendingFeedRequest
	*/
	FetchTrendingFeed(ctx context.Context) ApiFetchTrendingFeedRequest

	// FetchTrendingFeedExecute executes the request
	//  @return FeedResponse
	FetchTrendingFeedExecute(r ApiFetchTrendingFeedRequest) (*FeedResponse, *http.Response, error)

	/*
		FetchUserFollowingFeed Following

		Fetch feed based on who a user is following

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiFetchUserFollowingFeedRequest
	*/
	FetchUserFollowingFeed(ctx context.Context) ApiFetchUserFollowingFeedRequest

	// FetchUserFollowingFeedExecute executes the request
	//  @return FeedResponse
	FetchUserFollowingFeedExecute(r ApiFetchUserFollowingFeedRequest) (*FeedResponse, *http.Response, error)
}

// FeedAPIService FeedAPI service
type FeedAPIService service

type ApiFetchCastsForUserRequest struct {
	ctx                 context.Context
	ApiService          FeedAPI
	fid                 *int32
	appFid              *int32
	viewerFid           *int32
	limit               *int32
	cursor              *string
	includeReplies      *bool
	parentUrl           *string
	channelId           *string
	xNeynarExperimental *bool
}

// FID of user whose recent casts you want to fetch
func (r ApiFetchCastsForUserRequest) Fid(fid int32) ApiFetchCastsForUserRequest {
	r.fid = &fid
	return r
}

// Optionally filter to casts created via a specific app FID, e.g. 9152 for Warpcast
func (r ApiFetchCastsForUserRequest) AppFid(appFid int32) ApiFetchCastsForUserRequest {
	r.appFid = &appFid
	return r
}

// FID of the user viewing the feed
func (r ApiFetchCastsForUserRequest) ViewerFid(viewerFid int32) ApiFetchCastsForUserRequest {
	r.viewerFid = &viewerFid
	return r
}

// Number of results to fetch
func (r ApiFetchCastsForUserRequest) Limit(limit int32) ApiFetchCastsForUserRequest {
	r.limit = &limit
	return r
}

// Pagination cursor
func (r ApiFetchCastsForUserRequest) Cursor(cursor string) ApiFetchCastsForUserRequest {
	r.cursor = &cursor
	return r
}

// Include reply casts by the author in the response, true by default
func (r ApiFetchCastsForUserRequest) IncludeReplies(includeReplies bool) ApiFetchCastsForUserRequest {
	r.includeReplies = &includeReplies
	return r
}

// Parent URL to filter the feed; mutually exclusive with channel_id
func (r ApiFetchCastsForUserRequest) ParentUrl(parentUrl string) ApiFetchCastsForUserRequest {
	r.parentUrl = &parentUrl
	return r
}

// Channel ID to filter the feed; mutually exclusive with parent_url
func (r ApiFetchCastsForUserRequest) ChannelId(channelId string) ApiFetchCastsForUserRequest {
	r.channelId = &channelId
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiFetchCastsForUserRequest) XNeynarExperimental(xNeynarExperimental bool) ApiFetchCastsForUserRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiFetchCastsForUserRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FetchCastsForUserExecute(r)
}

/*
FetchCastsForUser Chronologically

Fetch casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchCastsForUserRequest
*/
func (a *FeedAPIService) FetchCastsForUser(ctx context.Context) ApiFetchCastsForUserRequest {
	return ApiFetchCastsForUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeedResponse
func (a *FeedAPIService) FetchCastsForUserExecute(r ApiFetchCastsForUserRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchCastsForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/user/casts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fid == nil {
		return localVarReturnValue, nil, reportError("fid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "form", "")
	if r.appFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_fid", r.appFid, "form", "")
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.includeReplies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_replies", r.includeReplies, "form", "")
	} else {
		var defaultValue bool = true
		r.includeReplies = &defaultValue
	}
	if r.parentUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_url", r.parentUrl, "form", "")
	}
	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channel_id", r.channelId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchFeedRequest struct {
	ctx                 context.Context
	ApiService          FeedAPI
	feedType            *FeedType
	filterType          *FilterType
	fid                 *int32
	fids                *string
	parentUrl           *string
	channelId           *string
	membersOnly         *bool
	embedUrl            *string
	embedTypes          *[]EmbedType
	withRecasts         *bool
	limit               *int32
	cursor              *string
	viewerFid           *int32
	xNeynarExperimental *bool
}

// Defaults to following (requires FID or address). If set to filter (requires filter_type)
func (r ApiFetchFeedRequest) FeedType(feedType FeedType) ApiFetchFeedRequest {
	r.feedType = &feedType
	return r
}

// Used when feed_type&#x3D;filter. Can be set to FIDs (requires FIDs) or parent_url (requires parent_url) or channel_id (requires channel_id)
func (r ApiFetchFeedRequest) FilterType(filterType FilterType) ApiFetchFeedRequest {
	r.filterType = &filterType
	return r
}

// (Optional) FID of user whose feed you want to create. By default, the API expects this field, except if you pass a filter_type
func (r ApiFetchFeedRequest) Fid(fid int32) ApiFetchFeedRequest {
	r.fid = &fid
	return r
}

// Used when filter_type&#x3D;FIDs . Create a feed based on a list of FIDs. Max array size is 100. Requires feed_type and filter_type.
func (r ApiFetchFeedRequest) Fids(fids string) ApiFetchFeedRequest {
	r.fids = &fids
	return r
}

// Used when filter_type&#x3D;parent_url can be used to fetch content under any parent url e.g. FIP-2 channels on Warpcast. Requires feed_type and filter_type.
func (r ApiFetchFeedRequest) ParentUrl(parentUrl string) ApiFetchFeedRequest {
	r.parentUrl = &parentUrl
	return r
}

// Used when filter_type&#x3D;channel_id can be used to fetch casts under a channel. Requires feed_type and filter_type.
func (r ApiFetchFeedRequest) ChannelId(channelId string) ApiFetchFeedRequest {
	r.channelId = &channelId
	return r
}

// Used when filter_type&#x3D;channel_id. Only include casts from members of the channel. True by default.
// Deprecated
func (r ApiFetchFeedRequest) MembersOnly(membersOnly bool) ApiFetchFeedRequest {
	r.membersOnly = &membersOnly
	return r
}

// Used when filter_type&#x3D;embed_url. Casts with embedded URLs prefixed by this embed_url param will be returned. We normalize your given URL prefix and prepend &#39;https://&#39; if no protocol is included. Requires feed_type and filter_type.
func (r ApiFetchFeedRequest) EmbedUrl(embedUrl string) ApiFetchFeedRequest {
	r.embedUrl = &embedUrl
	return r
}

// Used when filter_type&#x3D;embed_types can be used to fetch all casts with matching content types. Requires feed_type and filter_type.
func (r ApiFetchFeedRequest) EmbedTypes(embedTypes []EmbedType) ApiFetchFeedRequest {
	r.embedTypes = &embedTypes
	return r
}

// Include recasts in the response, true by default
func (r ApiFetchFeedRequest) WithRecasts(withRecasts bool) ApiFetchFeedRequest {
	r.withRecasts = &withRecasts
	return r
}

// Number of results to fetch
func (r ApiFetchFeedRequest) Limit(limit int32) ApiFetchFeedRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFetchFeedRequest) Cursor(cursor string) ApiFetchFeedRequest {
	r.cursor = &cursor
	return r
}

// Providing this will return a feed that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiFetchFeedRequest) ViewerFid(viewerFid int32) ApiFetchFeedRequest {
	r.viewerFid = &viewerFid
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiFetchFeedRequest) XNeynarExperimental(xNeynarExperimental bool) ApiFetchFeedRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiFetchFeedRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FetchFeedExecute(r)
}

/*
FetchFeed By filters

Fetch casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchFeedRequest
*/
func (a *FeedAPIService) FetchFeed(ctx context.Context) ApiFetchFeedRequest {
	return ApiFetchFeedRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeedResponse
func (a *FeedAPIService) FetchFeedExecute(r ApiFetchFeedRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchFeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.feedType == nil {
		return localVarReturnValue, nil, reportError("feedType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "feed_type", r.feedType, "form", "")
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_type", r.filterType, "form", "")
	}
	if r.fid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "form", "")
	}
	if r.fids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fids", r.fids, "form", "")
	}
	if r.parentUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_url", r.parentUrl, "form", "")
	}
	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channel_id", r.channelId, "form", "")
	}
	if r.membersOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "members_only", r.membersOnly, "form", "")
	} else {
		var defaultValue bool = true
		r.membersOnly = &defaultValue
	}
	if r.embedUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed_url", r.embedUrl, "form", "")
	}
	if r.embedTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed_types", r.embedTypes, "form", "csv")
	}
	if r.withRecasts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_recasts", r.withRecasts, "form", "")
	} else {
		var defaultValue bool = true
		r.withRecasts = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchFeedByChannelIdsRequest struct {
	ctx                 context.Context
	ApiService          FeedAPI
	channelIds          *string
	withRecasts         *bool
	viewerFid           *int32
	withReplies         *bool
	membersOnly         *bool
	fids                *string
	limit               *int32
	cursor              *string
	shouldModerate      *bool
	xNeynarExperimental *bool
}

// Comma separated list of up to 10 channel IDs e.g. neynar,farcaster
func (r ApiFetchFeedByChannelIdsRequest) ChannelIds(channelIds string) ApiFetchFeedByChannelIdsRequest {
	r.channelIds = &channelIds
	return r
}

// Include recasts in the response, true by default
func (r ApiFetchFeedByChannelIdsRequest) WithRecasts(withRecasts bool) ApiFetchFeedByChannelIdsRequest {
	r.withRecasts = &withRecasts
	return r
}

// Providing this will return a feed that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiFetchFeedByChannelIdsRequest) ViewerFid(viewerFid int32) ApiFetchFeedByChannelIdsRequest {
	r.viewerFid = &viewerFid
	return r
}

// Include replies in the response, false by default
func (r ApiFetchFeedByChannelIdsRequest) WithReplies(withReplies bool) ApiFetchFeedByChannelIdsRequest {
	r.withReplies = &withReplies
	return r
}

// Only include casts from members of the channel. True by default.
// Deprecated
func (r ApiFetchFeedByChannelIdsRequest) MembersOnly(membersOnly bool) ApiFetchFeedByChannelIdsRequest {
	r.membersOnly = &membersOnly
	return r
}

// Comma separated list of FIDs to filter the feed by, up to 10 at a time
func (r ApiFetchFeedByChannelIdsRequest) Fids(fids string) ApiFetchFeedByChannelIdsRequest {
	r.fids = &fids
	return r
}

// Number of results to fetch
func (r ApiFetchFeedByChannelIdsRequest) Limit(limit int32) ApiFetchFeedByChannelIdsRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFetchFeedByChannelIdsRequest) Cursor(cursor string) ApiFetchFeedByChannelIdsRequest {
	r.cursor = &cursor
	return r
}

// If true, only casts that have been liked by the moderator (if one exists) will be returned.
// Deprecated
func (r ApiFetchFeedByChannelIdsRequest) ShouldModerate(shouldModerate bool) ApiFetchFeedByChannelIdsRequest {
	r.shouldModerate = &shouldModerate
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiFetchFeedByChannelIdsRequest) XNeynarExperimental(xNeynarExperimental bool) ApiFetchFeedByChannelIdsRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiFetchFeedByChannelIdsRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FetchFeedByChannelIdsExecute(r)
}

/*
FetchFeedByChannelIds By channel IDs

Fetch feed based on channel IDs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchFeedByChannelIdsRequest
*/
func (a *FeedAPIService) FetchFeedByChannelIds(ctx context.Context) ApiFetchFeedByChannelIdsRequest {
	return ApiFetchFeedByChannelIdsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeedResponse
func (a *FeedAPIService) FetchFeedByChannelIdsExecute(r ApiFetchFeedByChannelIdsRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchFeedByChannelIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channelIds == nil {
		return localVarReturnValue, nil, reportError("channelIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "channel_ids", r.channelIds, "form", "")
	if r.withRecasts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_recasts", r.withRecasts, "form", "")
	} else {
		var defaultValue bool = true
		r.withRecasts = &defaultValue
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.withReplies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_replies", r.withReplies, "form", "")
	} else {
		var defaultValue bool = false
		r.withReplies = &defaultValue
	}
	if r.membersOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "members_only", r.membersOnly, "form", "")
	} else {
		var defaultValue bool = true
		r.membersOnly = &defaultValue
	}
	if r.fids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fids", r.fids, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.shouldModerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "should_moderate", r.shouldModerate, "form", "")
	} else {
		var defaultValue bool = false
		r.shouldModerate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchFeedByParentUrlsRequest struct {
	ctx                 context.Context
	ApiService          FeedAPI
	parentUrls          *string
	withRecasts         *bool
	viewerFid           *int32
	withReplies         *bool
	limit               *int32
	cursor              *string
	xNeynarExperimental *bool
}

// Comma separated list of parent_urls
func (r ApiFetchFeedByParentUrlsRequest) ParentUrls(parentUrls string) ApiFetchFeedByParentUrlsRequest {
	r.parentUrls = &parentUrls
	return r
}

// Include recasts in the response, true by default
func (r ApiFetchFeedByParentUrlsRequest) WithRecasts(withRecasts bool) ApiFetchFeedByParentUrlsRequest {
	r.withRecasts = &withRecasts
	return r
}

// Providing this will return a feed that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiFetchFeedByParentUrlsRequest) ViewerFid(viewerFid int32) ApiFetchFeedByParentUrlsRequest {
	r.viewerFid = &viewerFid
	return r
}

// Include replies in the response, false by default
func (r ApiFetchFeedByParentUrlsRequest) WithReplies(withReplies bool) ApiFetchFeedByParentUrlsRequest {
	r.withReplies = &withReplies
	return r
}

// Number of results to fetch
func (r ApiFetchFeedByParentUrlsRequest) Limit(limit int32) ApiFetchFeedByParentUrlsRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFetchFeedByParentUrlsRequest) Cursor(cursor string) ApiFetchFeedByParentUrlsRequest {
	r.cursor = &cursor
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiFetchFeedByParentUrlsRequest) XNeynarExperimental(xNeynarExperimental bool) ApiFetchFeedByParentUrlsRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiFetchFeedByParentUrlsRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FetchFeedByParentUrlsExecute(r)
}

/*
FetchFeedByParentUrls By parent URLs

Fetch feed based on parent URLs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchFeedByParentUrlsRequest
*/
func (a *FeedAPIService) FetchFeedByParentUrls(ctx context.Context) ApiFetchFeedByParentUrlsRequest {
	return ApiFetchFeedByParentUrlsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeedResponse
func (a *FeedAPIService) FetchFeedByParentUrlsExecute(r ApiFetchFeedByParentUrlsRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchFeedByParentUrls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/parent_urls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentUrls == nil {
		return localVarReturnValue, nil, reportError("parentUrls is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "parent_urls", r.parentUrls, "form", "")
	if r.withRecasts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_recasts", r.withRecasts, "form", "")
	} else {
		var defaultValue bool = true
		r.withRecasts = &defaultValue
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.withReplies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_replies", r.withReplies, "form", "")
	} else {
		var defaultValue bool = false
		r.withReplies = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchFeedForYouRequest struct {
	ctx                 context.Context
	ApiService          FeedAPI
	fid                 *int32
	viewerFid           *int32
	provider            *ForYouProvider
	limit               *int32
	cursor              *string
	providerMetadata    *string
	xNeynarExperimental *bool
}

// FID of user whose feed you want to create
func (r ApiFetchFeedForYouRequest) Fid(fid int32) ApiFetchFeedForYouRequest {
	r.fid = &fid
	return r
}

// Providing this will return a feed that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiFetchFeedForYouRequest) ViewerFid(viewerFid int32) ApiFetchFeedForYouRequest {
	r.viewerFid = &viewerFid
	return r
}

func (r ApiFetchFeedForYouRequest) Provider(provider ForYouProvider) ApiFetchFeedForYouRequest {
	r.provider = &provider
	return r
}

// Number of results to fetch
func (r ApiFetchFeedForYouRequest) Limit(limit int32) ApiFetchFeedForYouRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFetchFeedForYouRequest) Cursor(cursor string) ApiFetchFeedForYouRequest {
	r.cursor = &cursor
	return r
}

// provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.
func (r ApiFetchFeedForYouRequest) ProviderMetadata(providerMetadata string) ApiFetchFeedForYouRequest {
	r.providerMetadata = &providerMetadata
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiFetchFeedForYouRequest) XNeynarExperimental(xNeynarExperimental bool) ApiFetchFeedForYouRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiFetchFeedForYouRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FetchFeedForYouExecute(r)
}

/*
FetchFeedForYou For you

Fetch a personalized For You feed for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchFeedForYouRequest
*/
func (a *FeedAPIService) FetchFeedForYou(ctx context.Context) ApiFetchFeedForYouRequest {
	return ApiFetchFeedForYouRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeedResponse
func (a *FeedAPIService) FetchFeedForYouExecute(r ApiFetchFeedForYouRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchFeedForYou")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/for_you"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fid == nil {
		return localVarReturnValue, nil, reportError("fid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "form", "")
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	} else {
		var defaultValue ForYouProvider = "neynar"
		r.provider = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.providerMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider_metadata", r.providerMetadata, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FetchFeedForYou400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchFramesOnlyFeedRequest struct {
	ctx                 context.Context
	ApiService          FeedAPI
	limit               *int32
	viewerFid           *int32
	cursor              *string
	xNeynarExperimental *bool
}

// Number of results to fetch
func (r ApiFetchFramesOnlyFeedRequest) Limit(limit int32) ApiFetchFramesOnlyFeedRequest {
	r.limit = &limit
	return r
}

// Providing this will return a feed that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiFetchFramesOnlyFeedRequest) ViewerFid(viewerFid int32) ApiFetchFramesOnlyFeedRequest {
	r.viewerFid = &viewerFid
	return r
}

// Pagination cursor.
func (r ApiFetchFramesOnlyFeedRequest) Cursor(cursor string) ApiFetchFramesOnlyFeedRequest {
	r.cursor = &cursor
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiFetchFramesOnlyFeedRequest) XNeynarExperimental(xNeynarExperimental bool) ApiFetchFramesOnlyFeedRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiFetchFramesOnlyFeedRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FetchFramesOnlyFeedExecute(r)
}

/*
FetchFramesOnlyFeed Casts with mini apps

Fetch feed of casts with mini apps, reverse chronological order

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchFramesOnlyFeedRequest
*/
func (a *FeedAPIService) FetchFramesOnlyFeed(ctx context.Context) ApiFetchFramesOnlyFeedRequest {
	return ApiFetchFramesOnlyFeedRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeedResponse
func (a *FeedAPIService) FetchFramesOnlyFeedExecute(r ApiFetchFramesOnlyFeedRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchFramesOnlyFeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/frames"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchPopularCastsByUserRequest struct {
	ctx        context.Context
	ApiService FeedAPI
	fid        *int32
	viewerFid  *int32
}

// FID of user whose feed you want to create
func (r ApiFetchPopularCastsByUserRequest) Fid(fid int32) ApiFetchPopularCastsByUserRequest {
	r.fid = &fid
	return r
}

func (r ApiFetchPopularCastsByUserRequest) ViewerFid(viewerFid int32) ApiFetchPopularCastsByUserRequest {
	r.viewerFid = &viewerFid
	return r
}

func (r ApiFetchPopularCastsByUserRequest) Execute() (*BulkCastsResponse, *http.Response, error) {
	return r.ApiService.FetchPopularCastsByUserExecute(r)
}

/*
FetchPopularCastsByUser 10 most popular casts

Fetch 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchPopularCastsByUserRequest
*/
func (a *FeedAPIService) FetchPopularCastsByUser(ctx context.Context) ApiFetchPopularCastsByUserRequest {
	return ApiFetchPopularCastsByUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BulkCastsResponse
func (a *FeedAPIService) FetchPopularCastsByUserExecute(r ApiFetchPopularCastsByUserRequest) (*BulkCastsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkCastsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchPopularCastsByUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/user/popular"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fid == nil {
		return localVarReturnValue, nil, reportError("fid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "form", "")
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchRepliesAndRecastsForUserRequest struct {
	ctx        context.Context
	ApiService FeedAPI
	fid        *int32
	filter     *string
	limit      *int32
	cursor     *string
	viewerFid  *int32
}

// FID of user whose replies and recasts you want to fetch
func (r ApiFetchRepliesAndRecastsForUserRequest) Fid(fid int32) ApiFetchRepliesAndRecastsForUserRequest {
	r.fid = &fid
	return r
}

// filter to fetch only replies or recasts
func (r ApiFetchRepliesAndRecastsForUserRequest) Filter(filter string) ApiFetchRepliesAndRecastsForUserRequest {
	r.filter = &filter
	return r
}

// Number of results to fetch
func (r ApiFetchRepliesAndRecastsForUserRequest) Limit(limit int32) ApiFetchRepliesAndRecastsForUserRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFetchRepliesAndRecastsForUserRequest) Cursor(cursor string) ApiFetchRepliesAndRecastsForUserRequest {
	r.cursor = &cursor
	return r
}

// Providing this will return a feed that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiFetchRepliesAndRecastsForUserRequest) ViewerFid(viewerFid int32) ApiFetchRepliesAndRecastsForUserRequest {
	r.viewerFid = &viewerFid
	return r
}

func (r ApiFetchRepliesAndRecastsForUserRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FetchRepliesAndRecastsForUserExecute(r)
}

/*
FetchRepliesAndRecastsForUser Replies and recasts

Fetch recent replies and recasts for a given user FID; sorted by most recent first

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchRepliesAndRecastsForUserRequest
*/
func (a *FeedAPIService) FetchRepliesAndRecastsForUser(ctx context.Context) ApiFetchRepliesAndRecastsForUserRequest {
	return ApiFetchRepliesAndRecastsForUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeedResponse
func (a *FeedAPIService) FetchRepliesAndRecastsForUserExecute(r ApiFetchRepliesAndRecastsForUserRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchRepliesAndRecastsForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/user/replies_and_recasts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fid == nil {
		return localVarReturnValue, nil, reportError("fid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "form", "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	} else {
		var defaultValue string = "all"
		r.filter = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchTrendingFeedRequest struct {
	ctx                 context.Context
	ApiService          FeedAPI
	limit               *int32
	cursor              *string
	viewerFid           *int32
	timeWindow          *string
	channelId           *string
	parentUrl           *string
	provider            *FeedTrendingProvider
	providerMetadata    *string
	xNeynarExperimental *bool
}

// Number of results to fetch
func (r ApiFetchTrendingFeedRequest) Limit(limit int32) ApiFetchTrendingFeedRequest {
	r.limit = &limit
	return r
}

// Pagination cursor
func (r ApiFetchTrendingFeedRequest) Cursor(cursor string) ApiFetchTrendingFeedRequest {
	r.cursor = &cursor
	return r
}

// Providing this will return a feed that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiFetchTrendingFeedRequest) ViewerFid(viewerFid int32) ApiFetchTrendingFeedRequest {
	r.viewerFid = &viewerFid
	return r
}

// Time window for trending casts (7d window for channel feeds only)
func (r ApiFetchTrendingFeedRequest) TimeWindow(timeWindow string) ApiFetchTrendingFeedRequest {
	r.timeWindow = &timeWindow
	return r
}

// Channel ID to filter trending casts. Less active channels might have no casts in the time window selected. Provide either &#x60;channel_id&#x60; or &#x60;parent_url&#x60;, not both.
func (r ApiFetchTrendingFeedRequest) ChannelId(channelId string) ApiFetchTrendingFeedRequest {
	r.channelId = &channelId
	return r
}

// Parent URL to filter trending casts. Less active channels might have no casts in the time window selected. Provide either &#x60;channel_id&#x60; or &#x60;parent_url&#x60;, not both.
func (r ApiFetchTrendingFeedRequest) ParentUrl(parentUrl string) ApiFetchTrendingFeedRequest {
	r.parentUrl = &parentUrl
	return r
}

// The provider of the trending casts feed.
func (r ApiFetchTrendingFeedRequest) Provider(provider FeedTrendingProvider) ApiFetchTrendingFeedRequest {
	r.provider = &provider
	return r
}

// provider_metadata is a URI-encoded stringified JSON object that can be used to pass additional metadata to the provider. Only available for mbd provider right now. See [here](https://docs.neynar.com/docs/feed-for-you-w-external-providers) on how to use.
func (r ApiFetchTrendingFeedRequest) ProviderMetadata(providerMetadata string) ApiFetchTrendingFeedRequest {
	r.providerMetadata = &providerMetadata
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiFetchTrendingFeedRequest) XNeynarExperimental(xNeynarExperimental bool) ApiFetchTrendingFeedRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiFetchTrendingFeedRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FetchTrendingFeedExecute(r)
}

/*
FetchTrendingFeed Trending feeds

Fetch trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchTrendingFeedRequest
*/
func (a *FeedAPIService) FetchTrendingFeed(ctx context.Context) ApiFetchTrendingFeedRequest {
	return ApiFetchTrendingFeedRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeedResponse
func (a *FeedAPIService) FetchTrendingFeedExecute(r ApiFetchTrendingFeedRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchTrendingFeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.timeWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_window", r.timeWindow, "form", "")
	} else {
		var defaultValue string = "24h"
		r.timeWindow = &defaultValue
	}
	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channel_id", r.channelId, "form", "")
	}
	if r.parentUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_url", r.parentUrl, "form", "")
	}
	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	} else {
		var defaultValue FeedTrendingProvider = "neynar"
		r.provider = &defaultValue
	}
	if r.providerMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider_metadata", r.providerMetadata, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v FetchTrendingFeed400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchUserFollowingFeedRequest struct {
	ctx                 context.Context
	ApiService          FeedAPI
	fid                 *int32
	viewerFid           *int32
	withRecasts         *bool
	limit               *int32
	cursor              *string
	xNeynarExperimental *bool
}

// FID of user whose feed you want to create
func (r ApiFetchUserFollowingFeedRequest) Fid(fid int32) ApiFetchUserFollowingFeedRequest {
	r.fid = &fid
	return r
}

// Providing this will return a feed that respects this user&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
func (r ApiFetchUserFollowingFeedRequest) ViewerFid(viewerFid int32) ApiFetchUserFollowingFeedRequest {
	r.viewerFid = &viewerFid
	return r
}

// Include recasts in the response, true by default
func (r ApiFetchUserFollowingFeedRequest) WithRecasts(withRecasts bool) ApiFetchUserFollowingFeedRequest {
	r.withRecasts = &withRecasts
	return r
}

// Number of results to fetch
func (r ApiFetchUserFollowingFeedRequest) Limit(limit int32) ApiFetchUserFollowingFeedRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFetchUserFollowingFeedRequest) Cursor(cursor string) ApiFetchUserFollowingFeedRequest {
	r.cursor = &cursor
	return r
}

// Enables experimental features including filtering based on the Neynar score. See [docs](https://neynar.notion.site/Experimental-Features-1d2655195a8b80eb98b4d4ae7b76ae4a) for more details.
func (r ApiFetchUserFollowingFeedRequest) XNeynarExperimental(xNeynarExperimental bool) ApiFetchUserFollowingFeedRequest {
	r.xNeynarExperimental = &xNeynarExperimental
	return r
}

func (r ApiFetchUserFollowingFeedRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FetchUserFollowingFeedExecute(r)
}

/*
FetchUserFollowingFeed Following

Fetch feed based on who a user is following

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiFetchUserFollowingFeedRequest
*/
func (a *FeedAPIService) FetchUserFollowingFeed(ctx context.Context) ApiFetchUserFollowingFeedRequest {
	return ApiFetchUserFollowingFeedRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return FeedResponse
func (a *FeedAPIService) FetchUserFollowingFeedExecute(r ApiFetchUserFollowingFeedRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FetchUserFollowingFeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/following"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fid == nil {
		return localVarReturnValue, nil, reportError("fid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "form", "")
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "form", "")
	}
	if r.withRecasts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_recasts", r.withRecasts, "form", "")
	} else {
		var defaultValue bool = true
		r.withRecasts = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNeynarExperimental != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-neynar-experimental", r.xNeynarExperimental, "simple", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
